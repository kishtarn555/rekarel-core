
/**
 * This are opcodes which do not requiere arguments
 */

import { OpCode, RawProgram } from "./opcodes";

// TODO: complete the parser
interface Parser {
    /**
     * @throws It throws a error
     * @param str errorMessage
     * @param hash errorData
     */
    parseError(str: string, hash: any)
}

interface YY {
    parser: Parser
}

type YYLoc = {
    first_line: number,
    first_column: number,
    last_line: number,
    last_column: number,
}

/**
 * Represents the type of instructions that are available in the IR
 */
type IRInstruction =
    ["HALT"] |
    ["LINE", lineNumber: number] |
    ["LEFT"] |
    ["WORLDWALLS"] |
    ["ORIENTATION"] |
    ["ROTL"] |
    ["ROTR"] |
    ["MASK"] |
    ["NOT"] |
    ["AND"] |
    ["OR"] |
    ["EQ"] |
    ["EZ"] |
    ["JZ"] |
    ["JMP", offset: number] |
    ["FORWARD"] |
    ["WORLDBUZZERS"] |
    ["BAGBUZZERS"] |
    ["PICKBUZZER"] |
    ["LEAVEBUZZER"] |
    ["LOAD", value: number] |
    ["POP"] |
    ["DUP"] |
    ["DEC"] |
    ["INC"] |
    ["CALL", fname: string, argCount: string, nameLoc: YYLoc, argLoc: YYLoc] |
    ["RET"] |
    ["PARAM", index: number]
    ;

/**
 * IR Function representation
 */
type IRFunction = [name: string, code: null | IRInstruction[], params: [], loc: YYLoc]


/**
 * Represents an Intermediate Representation Object.
 *  It is used to abstract some logic from the parser and avoid repeating code for Pascal and Java interpreter
 */
export interface IRObject {
    compiler: string,
    language: string,
    packages: string[],
    program: IRInstruction[],
    functions: IRFunction[],
    requieresFunctionPrototypes: boolean,
    yy: YY //TODO: fix type
}


type PrototypeData = { argCount: number, defined: boolean };
type FunctionData = { location:number, arguments: string[] };
/**
 * Checks that functions calls are valid, not defined multiple times and prototypes match
 * @param data The IR generated by the parser
 */
export function validateFunctions(data: IRObject): boolean {
    const yy = data.yy;
    const prototypes = new Map<string, PrototypeData>();
    for (const func of data.functions) {
        const name = func[0];
        //Check if current func is a prototype
        if (func[1] == null) {
            if (prototypes.has(name)) {
                yy.parser.parseError("Prototype redefinition: " + name, {
                    text: name,
                    line: func[3].first_line - 1,
                    loc: func[3],
                });
                return false;
            }
            prototypes.set(name, { argCount: func[2].length, defined: false });
            continue;
        }

        if (!prototypes.has(name)) {
            prototypes.set(name, { argCount: func[2].length, defined: false });
        }
        const proto = prototypes.get(name);
        if (proto.defined) {
            yy.parser.parseError("Function redefinition: " + name, {
                text: name,
                line: func[3].first_line - 1,
                loc: func[3],
            });
            return false;
        }

        if (proto.argCount !== func[2].length) {
            yy.parser.parseError("Prototype parameter mismatch: " + name, {
                text: name,
                line: func[3].first_line - 1,
                loc: func[3],
            });
            return false;
        }

        prototypes.set(name, { argCount: func[2].length, defined: true });

        if (!data.requieresFunctionPrototypes)
            continue;
        //This check are only needed if declaration order mater, for languages like C or Pascal
        //Checks that the function called at this time has been declared above.
        for (const instruction of func[1]) {
            if (instruction[0] !== "CALL")
                continue;

            const target = instruction[1];

            if (prototypes.has(target))
                continue;

            yy.parser.parseError("Undefined function: " + target, {
                text: target,
                line: instruction[3].first_line - 1,
                loc: instruction[3]
            });
            return false;
        }

    }
    return true;
}

/**
 * 
 * @param data IntermediateRepresentation Object
 * @param keywords Set of keywords, each package may add it
 */
function loadPackages(data:IRObject, externDefinitions:Set<string>) {
    
}

export function generateOpcodesFromIR(data: IRObject): RawProgram {

    const externDefinitions = new Set<string>();

    loadPackages(data, externDefinitions);

    if (validateFunctions(data))
        throw new Error("This should not be reachable, it should have thrown before");

    const IRProgram :IRInstruction[] = [...data.program];


    const funcData = new Map<string, FunctionData>();


    return program;
}
