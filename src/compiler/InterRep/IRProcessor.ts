import { RawProgram } from "../opcodes";
import { CompilerPackage, UnitePackages } from "../packages/package";
import { JavaPackages, PascalPackages } from "../packages/rekarel.all";
import { YY, YYLoc } from "./IRParserTypes";
import { IRFunction, IRInstruction, IRParam, IRSemiSimpleInstruction, IRSimpleInstruction, IRTagRecord } from "./IRInstruction";
import { DefinitionTable, FunctionData } from "./IRVarTable";
import { resolveListWithASTs } from "./AstExpression";
import { MAIN_SCOPE, Scope } from "./Scope";
import { CompilationError } from "./compileErrors";
import { DebugData } from "../debugData";



/**
 * Represents an Intermediate Representation Object.
 *  It is used to abstract some logic from the parser and avoid repeating code for Pascal and Java interpreter
 */
export interface IRObject {
    compiler: string,
    language: string,
    packages: [string, YYLoc][],
    program: IRInstruction[],
    functions: IRFunction[],
    requieresFunctionPrototypes: boolean,
    variablesCanBeFunctions: boolean
    yy: YY //TODO: fix type
}


type PrototypeData = { 
    argCount: number, 
    defined: boolean, 
    returnType:string 
};

/**
 * Checks that functions calls are valid, not defined multiple times and prototypes match
 * @param data The IR generated by the parser
 * @param bundle The bundle generated by the packages
 * @param definitionTable The definition table to populate
 */
function validateAndGetFunctionDefinitions(data: IRObject, definitionTable: DefinitionTable): boolean {
    const yy = data.yy;
    const prototypes = new Map<string, PrototypeData>();
    for (const func of data.functions) {
        //Check that the parameters do not overload a global
        for (const parameter of func.params) {
            if (definitionTable.hasVar(parameter.name)) {
                yy.parser.parseError("Cannot name a parameter as a global variable", {
                    error: CompilationError.Errors.PARAMETER_ILLEGAL_NAME,
                    parameterName: parameter.name,
                    line: parameter.loc.first_line - 1,
                    loc: parameter.loc
                })
                return false;
            }
        }

        // Check that the function does not shadow a variable
        if (definitionTable.hasVar(func.name)) {
            yy.parser.parseError("Cannot name a function as a global variable", {
                error: CompilationError.Errors.FUNCTION_ILLEGAL_NAME,
                functionName: func.name,
                line: func.loc.first_line - 1,
                loc: func.loc
            })
            return false;
        }

        //Check if current func is a prototype
        if (func.code == null) {
            if (prototypes.has(func.name)) {
                yy.parser.parseError("Prototype redefinition: " + func.name, {
                    error: CompilationError.Errors.PROTOTYPE_REDEFINITION,
                    prototypeName: func.name,
                    line: func.loc.first_line - 1,
                    loc: func.loc,
                });
                return false;
            }
            prototypes.set(
                func.name, 
                { 
                    argCount: func.params.length, 
                    defined: false,
                    returnType: func.returnType
                }
            );
            continue;
        }

        if (!prototypes.has(func.name)) {
            prototypes.set(
                func.name, 
                { 
                    argCount: func.params.length,
                    defined: false,
                    returnType: func.returnType
                }
            );
        }
        const proto = prototypes.get(func.name);
        if (proto.defined) {
            yy.parser.parseError("Function redefinition: " + func.name, {
                error: CompilationError.Errors.FUNCTION_REDEFINITION,
                functionName: func.name,
                line: func.loc.first_line - 1,
                loc: func.loc,
            });
            return false;
        }

        if (proto.argCount !== func.params.length) {
            yy.parser.parseError("Prototype parameter mismatch: " + func.name, {
                error: CompilationError.Errors.PROTOTYPE_PARAMETERS_MISS_MATCH,
                line: func.loc.first_line - 1,
                loc: func.loc,
                functionName: func.name,
                functionParamCount: func.params.length,
                prototypeParamCount: proto.argCount
            });
            return false;
        }

        if (proto.returnType !== func.returnType) {
            yy.parser.parseError("Prototype type mismatch: " + func.name, {
                error: CompilationError.Errors.PROTOTYPE_TYPE_MISS_MATCH,
                line: func.loc.first_line - 1,
                loc: func.loc,
                functionName: func.name,
                functionType: func.returnType,
                prototypeType: proto.returnType
            });
            return false;
        }

        prototypes.set(
            func.name, 
            {
                argCount: func.params.length,
                defined: true,
                returnType: func.returnType
            }
        );
        definitionTable.registerFunction(func);


        for (const instruction of func.code) {
            if (data.requieresFunctionPrototypes && instruction[0] === "CALL") {
                //This check is only needed if declaration order mater, for languages like C or Pascal
                //Checks that the function called at this time has been declared above.
                const data = instruction[1];
                if (!prototypes.has(data.target)) {


                    yy.parser.parseError("Undefined function: " + data.target, {
                        error: CompilationError.Errors.UNDEFINED_FUNCTION,
                        functionName: data.target,
                        line: data.nameLoc.first_line - 1,
                        loc: data.nameLoc
                    });
                    return false;
                }
            }
        }

    }

    //Validate parameters
    for (const func of data.functions) {
        func.params.forEach((param, idx) => {
            if( definitionTable.hasVar(param.name) || definitionTable.hasFunction(param.name)) {
                yy.parser.parseError(`Cannot name parameter ${param.name} as it is already used by a variable or function`, {
                    error: CompilationError.Errors.PARAMETER_ILLEGAL_NAME,
                    line: param.loc.first_line - 1,
                    loc: param.loc,
                    parameterName: param.name
                });
            }
            const first = func.params.findIndex(p => p.name === param.name);
            if (first !== idx) {
                yy.parser.parseError(`Parameter ${param.name} was already declared in the function`, {
                    error: CompilationError.Errors.PARAMETER_REDEFINITION,
                    line: param.loc.first_line - 1,
                    loc: param.loc,
                    parameterName: param.name
                }); 
            }

        });
    }

    return true;
}

/**
 * This functions  creates a  bundle with all packages that the code has
 * @throws Compilation error if it imports and invalid package
 * @param data IntermediateRepresentation Object
 * @param keywords Set of keywords, each package may add it
 */
function loadPackages(data: IRObject, definitions: DefinitionTable) {
    const compPackages = data.language === "ReKarel Java" ? JavaPackages : PascalPackages;
    const yy = data.yy;

    for (const pack of data.packages) {
        const packageName = pack[0].split(".")[0];
        const moduleName = pack[0].split(".")[1];

        if (packageName !== "rekarel") {
            yy.parser.parseError("Package not recognized: " + pack[0], {
                error: CompilationError.Errors.UNKNOWN_PACKAGE,
                package: packageName,
                module: moduleName,
                full: pack[0],
                loc: pack[1],
                line: pack[1].first_line - 1,
            });
        }
        if (!compPackages[pack[0]]) {
            yy.parser.parseError("Module not found: " + pack[0], {
                error: CompilationError.Errors.UNKNOWN_MODULE,
                package: packageName,
                module: moduleName,
                full: pack[0],
                loc: pack[1],
                line: pack[1].first_line - 1,
            });
        }
        const packObject: CompilerPackage = compPackages[pack[0]];
        for (let [varName, varVal] of packObject.numberVariables) {
            definitions.registerVar(
                varName,
                {
                    instructions: varVal,
                    dataType: "INT",
                }
            )
        }
        for (let [varName, varVal] of packObject.booleanVariables) {
            definitions.registerVar(
                varName,
                {
                    instructions: varVal,
                    dataType: "BOOL",
                }
            )
        }
    }



}

/**
 * Resolves AST instructions, Tags and TJMP. 
 * @throws If there's a type error
 * @param IRInstructions The instructions to resolve
 * @param yy Compiler information, used to throw compilation errors
 * @param definitions Table of global definitions
 * @param parameters Parameters of the scope
 * @param expectedReturn The return type of the current scope
 * @returns The IR with the complex IR resolved into simple IR
 */
function resolveComplexIR(IRInstructions: IRInstruction[], yy: YY, definitions: DefinitionTable, scope: Scope, func?: IRFunction): IRSimpleInstruction[] {
    let result: IRSemiSimpleInstruction[] = [];
    const tags: IRTagRecord = {};
    //Resolve AST and populate tags
    let info = resolveListWithASTs(IRInstructions, definitions, scope, result, tags, yy);

    // Check for explicit returns
    if (scope.expectedReturn !== "VOID" && !info.explicitReturn) {
        yy.parser.parseError(`Explicit return is required in function ${func!.name}`, {
            error: CompilationError.Errors.NO_EXPLICIT_RETURN,
            loc: func.loc,
            line: func.loc.first_line - 1,
            functionName: func!.name,
            returnType: scope.expectedReturn,
        } );

    }

    // Resolve TJMP to JMP
    return result.map((instruction, idx): IRSimpleInstruction => {
        if (instruction[0] === "TJMP") {
            const delta = tags[instruction[1]] - idx - 1;
            return ["JMP", delta];
        }
        if (instruction[0] === "TJZ") {
            const delta = tags[instruction[1]] - idx - 1;
            return ["JZ", delta];
        }
        return instruction
    });
}

export function generateOpcodesFromIR(data: IRObject, exportDebug: boolean): RawProgram | [RawProgram, DebugData] {
    const definitions = new DefinitionTable(data.variablesCanBeFunctions);
    const debugData = new DebugData();
    // Step 1 - Populate global definitions, and check for repeated definitions
    loadPackages(data, definitions);
    if (!validateAndGetFunctionDefinitions(data, definitions))
        throw new Error("This should not be reachable, it should have thrown before");

    // Step 2 - Resolve all AST/tags, such as terms.
    let IRProgram = resolveComplexIR(data.program, data.yy, definitions, MAIN_SCOPE);

    // Step 3 - Resolve all AST/tags from functions and Generate a single IR array.
    for (const func of data.functions) {
        if (func.code == null) {
            //Skip prototypes
            continue;
        }
        definitions.setFunctionLoc(func.name, IRProgram.length);
        const functionScope = new Scope({
            parameters: func.params,
            expectedReturn: func.returnType
        });
        const code = resolveComplexIR(func.code, data.yy, definitions, functionScope, func);
        IRProgram = IRProgram.concat(code);
    }
    //Step 4: Generate opcode. Resolve CALL into correct opcode
    const program: RawProgram = []
    for (const instruction of IRProgram) {
        if (instruction[0] === "CALL") {
            const iData = instruction[1];
            if (!definitions.hasFunction(iData.target)) {
                data.yy.parser.parseError("Undefined function: " + iData.target, {
                    error: CompilationError.Errors.UNDEFINED_FUNCTION,
                    functionName: iData.target,
                    line: iData.nameLoc.first_line - 1,
                    loc: iData.nameLoc
                });
                return null;
            }
            const targetFunc = definitions.getFunction(iData.target);
            if (targetFunc.arguments.length < iData.params.length) {
                const extraParam = iData.params[iData.params.length - targetFunc.arguments.length - 1];
                data.yy.parser.parseError(
                    `Too many parameters in call to function ${iData.target}, expected ${targetFunc.arguments.length}, got ${iData.params.length}`, 
                    {
                        error: CompilationError.Errors.TOO_MANY_PARAMS_IN_CALL,
                        line: extraParam.totalLoc.first_line - 1,
                        loc: extraParam.totalLoc,
                        functionName: iData.target,
                        expectedParams: iData.params.length,
                        actualParams: targetFunc.arguments.length
                    }
                );
            }
            if (targetFunc.arguments.length > iData.params.length) {
                data.yy.parser.parseError(
                    `Too few parameters in call to function ${iData.target}, expected ${targetFunc.arguments.length}, got ${iData.params.length}`, 
                    {
                        error: CompilationError.Errors.TOO_FEW_PARAMS_IN_CALL,
                        line: iData.nameLoc.first_line - 1,
                        loc: iData.nameLoc,
                        funcName: iData.target,
                        expectedParams: iData.params.length,
                        actualParams: targetFunc.arguments.length
                    }
                );
            }
            if (iData.expectedType != null && iData.expectedType !== targetFunc.returnType) {
                data.yy.parser.parseError(`Expected a function of type ${iData.expectedType}, but ${iData.target} is ${targetFunc.returnType}`, {
                    error: CompilationError.Errors.CALL_TYPE,
                    line: iData.nameLoc.first_line - 1,
                    loc: iData.nameLoc,
                    funcName: iData.target,
                    expectedCallType: iData.expectedType,
                    functionType: targetFunc.returnType
                });
            }

            program.push([
                "CALL",
                targetFunc.location,
                iData.target,
            ]);
            continue;
        }
        if (instruction[0] === "RET") {
            program.push(["RET"]);
            continue;
        }
        program.push(instruction);
    }

    if (exportDebug) {        
        debugData.definitions = definitions;
        return [program, debugData];
    }
    return program;
}
